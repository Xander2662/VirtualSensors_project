/**
 * @file protocol.cpp
 * @brief Implementation of the Protocol class for handling API communication protocol.
 * 
 * This file implements the Protocol class static methods for managing sensor communication
 * using a URL-like protocol format. It handles initialization, data updates, configuration,
 * reset, connect, and disconnect operations for sensors.
 * 
 * @copyright 2024 MTA
 * @author Generated by GitHub Copilot
 */

#include "protocol.hpp"

#include <sstream>
#include <algorithm> // For std::transform

// Static member definitions
const std::string Protocol::API_VERSION = "1.2";
bool Protocol::initialized = false;

std::unordered_map<std::string, std::string> Protocol::parseMessage(const std::string& message, bool caseSensitive) {
    static std::unordered_map<std::string, std::string> params;
    params.clear();
    
    // Remove leading '?' if present
    std::string cleanMessage = message;
    if(!caseSensitive)
    {
        // Convert to lowercase
        std::transform(cleanMessage.begin(), cleanMessage.end(), cleanMessage.begin(), ::tolower);
    }

    if (!cleanMessage.empty() && cleanMessage[0] == '?') {
        cleanMessage = cleanMessage.substr(1);
    }
    
    // Split by '&' to get key-value pairs
    std::stringstream ss(cleanMessage);
    std::string pair;
    
    while (std::getline(ss, pair, '&')) {
        size_t equalPos = pair.find('=');
        if (equalPos != std::string::npos) {
            std::string key = pair.substr(0, equalPos);
            std::string value = pair.substr(equalPos + 1);
            params[key] = value;
        }
    }
    
    return params;
}

std::string Protocol::buildMessage(const std::unordered_map<std::string, std::string>& params) {
    std::stringstream ss;
    ss << "?";
    
    bool first = true;
    for (const auto& pair : params) {
        if (!first) {
            ss << "&";
        }
        ss << pair.first << "=" << pair.second;
        first = false;
    }
    
    return ss.str();
}

ResponseStatus Protocol::init_dummy() {
    ResponseStatus response;
    
    // First init messenger
    initMessenger();

    // Build initialization request
    std::string request = "?type=INIT";
 
    // Send request and receive response
    sendMessage(request); 

    //dummy response for test mode - always successful
    response.status = ResponseStatusEnum::OK;
    response.error = "";
    
    // Thats all
    initialized = true;
    return response;
}

ResponseStatus Protocol::init() {
    ResponseStatus response;
    response.status = ResponseStatusEnum::ERROR;
    
    // First init messenger
    initMessenger();
    
    // Build initialization request
    std::string request = "?type=INIT";
    request += "&api=" + API_VERSION;

    // Send request and receive response
    sendMessage(request); 
    std::string responseMsg = receiveMessage(PROTOCOL_VERBOSE, PROTOCOL_INIT_TIMEOUT); 
    
    // Parse response
    auto responseParams = parseMessage(responseMsg);
    
    // Check if initialization was successful
    if (responseParams.find("status") == responseParams.end() || responseParams["status"] != "1") {
        response.status = ResponseStatusEnum::ERROR;
        response.error = responseParams.find("error") != responseParams.end() 
                            ? responseParams["error"] : "Initialization failed - bad or missing status";
    } else {
        response.status = ResponseStatusEnum::OK;
        response.error = "";
        initialized = true;
    }
    
    return response;
}

ResponseStatus Protocol::init(const std::string& db_version) {
    ResponseStatus response;
    response.status = ResponseStatusEnum::ERROR;
    
    // First init messenger
    initMessenger();
    
    // Build initialization request
    std::string request = "?type=INIT";
    request += "&db=" + db_version;
    request += "&api=" + API_VERSION;
    
    // Send request and receive response
    sendMessage(request); 
    std::string responseMsg = receiveMessage(PROTOCOL_VERBOSE, PROTOCOL_INIT_TIMEOUT); 
    
    // Parse response
    auto responseParams = parseMessage(responseMsg);
    
    // Check if initialization was successful
    if (responseParams.find("status") == responseParams.end() || responseParams["status"] != "1") {
        response.status = ResponseStatusEnum::ERROR;
        response.error = responseParams.find("error") != responseParams.end() 
                            ? responseParams["error"] : "Initialization failed - bad or missing status";
    } else {
        response.status = ResponseStatusEnum::OK;
        response.error = "";
        initialized = true;
    }
    
    return response;
}

ResponseStatus Protocol::init(const std::string& app_name, const std::string& db_version) {
    ResponseStatus response;
    response.status = ResponseStatusEnum::ERROR;
    
    // First init messenger
    initMessenger();
    
    // Build initialization request
    std::string request = "?type=INIT";
    request += "&app=" + app_name;
    request += "&db=" + db_version;
    request += "&api=" + API_VERSION;
    
    // Send request and receive response
    sendMessage(request); 
    std::string responseMsg = receiveMessage(PROTOCOL_VERBOSE, PROTOCOL_INIT_TIMEOUT); 
    
    // Parse response
    auto responseParams = parseMessage(responseMsg);
    
    // Check if initialization was successful
    if (responseParams.find("status") == responseParams.end() || responseParams["status"] != "1") {
        response.status = ResponseStatusEnum::ERROR;
        response.error = responseParams.find("error") != responseParams.end() 
                            ? responseParams["error"] : "Initialization failed - bad or missing status";
    } else {
        response.status = ResponseStatusEnum::OK;
        response.error = "";
        initialized = true;
    }
    
    return response;
}

ResponseStatus Protocol::update(const std::string& uid) {
    ResponseStatus response;
    response.status = ResponseStatusEnum::ERROR;

    if (!initialized) {
        response.error = "Protocol not initialized";
        return response;
    }
    
    if (uid.empty()) {
        response.error = "UID cannot be empty";
        return response;
    }

    // Build update request
    std::string request = "?type=UPDATE";
    request += "&id=" + uid;
    
    // Send request and receive response
    sendMessage(request);
    std::string responseMsg = receiveMessage(PROTOCOL_VERBOSE); // Use defined verbosity for receive
    
    // Parse response
    auto responseParams = parseMessage(responseMsg);
    
    // Check if UID from response matches request
    if (responseParams.find("id") == responseParams.end() || responseParams["id"] != uid) {
        response.error = "Response UID mismatch - expected: " + uid + ", received: " + 
                                (responseParams.find("id") != responseParams.end() ? responseParams["id"] : "none");
        return response;
    }
    
    // Check if update was successful
    if (responseParams.find("status") == responseParams.end() || responseParams["status"] != "1") {
        response.status = ResponseStatusEnum::ERROR;
        response.error = responseParams.find("error") != responseParams.end() 
                            ? responseParams["error"] : "Update failed - bad or missing status";
    } else {
        response.status = ResponseStatusEnum::OK;
        response.error = "";
    }

    // For update method only, return all response parameters
    response.params = responseParams;

    return response; 
}

ResponseStatus Protocol::config(const std::string& uid, const std::unordered_map<std::string, std::string>& config) {
    ResponseStatus response;
    response.status = ResponseStatusEnum::ERROR;

    if (!initialized) {
        response.error = "Protocol not initialized";
        return response;
    }
    
    if (uid.empty()) {
        response.error = "UID cannot be empty";
        return response;
    }

    // Build configuration request
    std::string request = "?type=CONFIG";
    request += "&id=" + uid;
    
    // Add configuration parameters
    for (const auto& configParam : config) {
        request += "&" + configParam.first + "=" + configParam.second;
    }
    
    // Send request and receive response
    sendMessage(request);
    std::string responseMsg = receiveMessage(PROTOCOL_VERBOSE); // Use defined verbosity for receive
    
    // Parse response
    auto responseParams = parseMessage(responseMsg);
    
    // Check if UID from response matches request
    if (responseParams.find("id") == responseParams.end() || responseParams["id"] != uid) {
        response.error = "Response UID mismatch - expected: " + uid + ", received: " + 
                                (responseParams.find("id") != responseParams.end() ? responseParams["id"] : "none");
        return response;
    }
    
    // Check if configuration was successful
    if (responseParams.find("status") == responseParams.end() || responseParams["status"] != "1") {
        response.status = ResponseStatusEnum::ERROR;
        response.error = responseParams.find("error") != responseParams.end() 
                            ? responseParams["error"] : "Configuration failed - bad or missing status";
    } else {
        response.status = ResponseStatusEnum::OK;
        response.error = "";
    }

    return response;
}

ResponseStatus Protocol::reset(const std::string& uid) {
    ResponseStatus response;
    response.status = ResponseStatusEnum::ERROR;

    if (!initialized) {
        response.error = "Protocol not initialized";
        return response;
    }
    
    if (uid.empty()) {
        response.error = "UID cannot be empty";
        return response;
    }

    // Build reset request
    std::string request = "?type=RESET";
    request += "&id=" + uid;
    
    // Send request and receive response
    sendMessage(request);
    std::string responseMsg = receiveMessage(PROTOCOL_VERBOSE); // Use defined verbosity for receive
    
    // Parse response
    auto responseParams = parseMessage(responseMsg);
    
    // Check if UID from response matches request
    if (responseParams.find("id") == responseParams.end() || responseParams["id"] != uid) {
        response.error = "Response UID mismatch - expected: " + uid + ", received: " + 
                                (responseParams.find("id") != responseParams.end() ? responseParams["id"] : "none");
        return response;
    }
    
    // Check if reset was successful
    if (responseParams.find("status") == responseParams.end() || responseParams["status"] != "1") {
        response.status = ResponseStatusEnum::ERROR;
        response.error = responseParams.find("error") != responseParams.end() 
                            ? responseParams["error"] : "Reset failed - bad or missing status";
    } else {
        response.status = ResponseStatusEnum::OK;
        response.error = "";
    }

    return response;
}

ResponseStatus Protocol::connect(const std::string& uid, const std::string& pins) {
    ResponseStatus response;
    response.status = ResponseStatusEnum::ERROR;

    if (!initialized) {
        response.error = "Protocol not initialized";
        return response;
    }
    
    if (uid.empty()) {
        response.error = "UID cannot be empty";
        return response;
    }

    // Build connect request
    std::string request = "?type=CONNECT";
    request += "&id=" + uid;
    request += "&pins=" + pins;
    
    // Send request and receive response
    sendMessage(request);
    std::string responseMsg = receiveMessage(PROTOCOL_VERBOSE); // Use defined verbosity for receive
    
    // Parse response
    auto responseParams = parseMessage(responseMsg);
    
    // Check if UID from response matches request
    if (responseParams.find("id") == responseParams.end() || responseParams["id"] != uid) {
        response.error = "Response UID mismatch - expected: " + uid + ", received: " + 
                                (responseParams.find("id") != responseParams.end() ? responseParams["id"] : "none");
        return response;
    }
    
    // Check if connection was successful
    if (responseParams.find("status") == responseParams.end() || responseParams["status"] != "1") {
        response.status = ResponseStatusEnum::ERROR;
        response.error = responseParams.find("error") != responseParams.end() 
                            ? responseParams["error"] : "Connection failed - bad or missing status";
    } else {
        response.status = ResponseStatusEnum::OK;
        response.error = "";
    }

    return response;
}

ResponseStatus Protocol::disconnect(const std::string& uid) {
    ResponseStatus response;
    response.status = ResponseStatusEnum::ERROR;

    if (!initialized) {
        response.error = "Protocol not initialized";
        return response;
    }
    
    if (uid.empty()) {
        response.error = "UID cannot be empty";
        return response;
    }

    // Build disconnect request
    std::string request = "?type=DISCONNECT";
    request += "&id=" + uid;
    
    // Send request and receive response
    sendMessage(request);
    std::string responseMsg = receiveMessage(PROTOCOL_VERBOSE); // Use defined verbosity for receive
    
    // Parse response
    auto responseParams = parseMessage(responseMsg);
    
    // Check if UID from response matches request
    if (responseParams.find("id") == responseParams.end() || responseParams["id"] != uid) {
        response.error = "Response UID mismatch - expected: " + uid + ", received: " + 
                                (responseParams.find("id") != responseParams.end() ? responseParams["id"] : "none");
        return response;
    }
    
    // Check if disconnection was successful
    if (responseParams.find("status") == responseParams.end() || responseParams["status"] != "1") {
        response.status = ResponseStatusEnum::ERROR;
        response.error = responseParams.find("error") != responseParams.end() 
                            ? responseParams["error"] : "Disconnection failed - bad or missing status";
    } else {
        response.status = ResponseStatusEnum::OK;
        response.error = "";
    }

    return response;
}

bool Protocol::isInitialized() {
    return initialized;
}

std::string Protocol::getApiVersion() {
    return API_VERSION;
}