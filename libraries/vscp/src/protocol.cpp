/**
 * @file protocol.cpp
 * @brief Implementation of the Protocol class for handling API communication protocol.
 * 
 * This file implements the Protocol class static methods for managing sensor communication
 * using a URL-like protocol format. It handles initialization, data updates, configuration,
 * reset, connect, and disconnect operations for sensors.
 * 
 * @copyright 2024 MTA
 * @author Generated by GitHub Copilot
 */

#include "protocol.hpp"

#include <sstream>
#include <algorithm> // For std::transform

// Static member definitions
const std::string Protocol::API_VERSION = "1.2";
bool Protocol::initialized = false;

std::unordered_map<std::string, std::string> Protocol::parseMessage(const std::string& message, bool caseSensitive) {
    static std::unordered_map<std::string, std::string> params;
    params.clear();
    
    // Remove leading '?' if present
    std::string cleanMessage = message;
    if(!caseSensitive)
    {
        // Convert to lowercase
        std::transform(cleanMessage.begin(), cleanMessage.end(), cleanMessage.begin(), ::tolower);
    }

    if (!cleanMessage.empty() && cleanMessage[0] == '?') {
        cleanMessage = cleanMessage.substr(1);
    }
    
    // Split by '&' to get key-value pairs
    std::stringstream ss(cleanMessage);
    std::string pair;
    
    while (std::getline(ss, pair, '&')) {
        size_t equalPos = pair.find('=');
        if (equalPos != std::string::npos) {
            std::string key = pair.substr(0, equalPos);
            std::string value = pair.substr(equalPos + 1);
            params[key] = value;
        }
    }
    
    return params;
}

std::string Protocol::buildMessage(const std::unordered_map<std::string, std::string>& params) {
    std::stringstream ss;
    ss << "?";
    
    bool first = true;
    for (const auto& pair : params) {
        if (!first) {
            ss << "&";
        }
        ss << pair.first << "=" << pair.second;
        first = false;
    }
    
    return ss.str();
}

bool Protocol::init_dummy(int verbose) {
    // First init messenger
    initMessenger();

    // Build initialization request
    std::string request = "?type=INIT";
 
    // Send request and receive response
    sendMessage(request); 

    // Thats all
    initialized = true;
    return initialized;
}

bool Protocol::init(int verbose)  {
    // First init messenger
    initMessenger();
    
    // Build initialization request
    static std::string request;
    std::string request = "?type=INIT";
    request += "&api=" + API_VERSION;

    // Send request and receive response
    sendMessage(request); 
    std::string response = receiveMessage(500, verbose); // 500 ms timeout for init
    
    // Parse response
    auto responseParams = parseMessage(response);
    
    // Check if initialization was successful
    if (responseParams.find("status") != responseParams.end()) {
        initialized = (responseParams["status"] == "1");
    }
    else{
        initialized = false;
    }
    
    return initialized;
}

bool Protocol::init(const std::string& db_version, int verbose)  {
    // First init messenger
    initMessenger();
    
    // Build initialization request
    std::unordered_map<std::string, std::string> params;
    params["type"] = "INIT";
    params["db"] = db_version;
    params["api"] = API_VERSION;
    
    std::string request = buildMessage(params);
    
    // Send request and receive response
    sendMessage(request); 
    std::string response = receiveMessage(500); // 500 ms timeout for init
    
    // Parse response
    auto responseParams = parseMessage(response, verbose);
    
    // Check if initialization was successful
    if (responseParams.find("status") != responseParams.end()) {
        initialized = (responseParams["status"] == "1");
    }
    else{
        initialized = false;
    }
    
    return initialized;
}


bool Protocol::init(const std::string& app_name, const std::string& db_version, int verbose) {
    // First init messenger
    initMessenger();
    
    // Build initialization request
    std::unordered_map<std::string, std::string> params;
    params["type"] = "INIT";
    params["app"] = app_name;
    params["db"] = db_version;
    params["api"] = API_VERSION;
    
    std::string request = buildMessage(params);
    
    // Send request and receive response
    sendMessage(request); 
    std::string response = receiveMessage(500); // 500 ms timeout for init
    
    // Parse response
    auto responseParams = parseMessage(response);
    
    // Check if initialization was successful
    if (responseParams.find("status") != responseParams.end()) {
        initialized = (responseParams["status"] == "1");
    }
    else{
        initialized = false;
    }
    
    return initialized;
}

std::unordered_map<std::string, std::string> Protocol::update(const std::string& uid, int verbose) {
    auto responseParams = std::unordered_map<std::string, std::string>();
    std::string errorMessage = "";

    if (!initialized) {
        responseParams["error"] = "Protocol not initialized";
        return responseParams; // Return error map in silent mode
    }
    
    if (uid.empty()) {
        responseParams["error"] = "UID cannot be empty";
        return responseParams; // Return error map in silent mode
    }

    // Build update request
    std::string request = "?type=UPDATE";
    request += "&id=" + uid;
    
    // Send request and receive response
    sendMessage(request);
    std::string response = receiveMessage(verbose);
    
    // Parse response
    responseParams = parseMessage(response);
    
    // Check if UID from response matches request
    if (responseParams.find("id") == responseParams.end() || responseParams["id"] != uid) {
        errorMessage = "Response UID mismatch - expected: " + uid + ", received: " + 
                                (responseParams.find("id") != responseParams.end() ? responseParams["id"] : "none");
        responseParams["error"] = errorMessage;
        return responseParams;
    }
    
    // Check if update was successful
    if (responseParams.find("status") == responseParams.end() || responseParams["status"] != "1") {
        errorMessage = responseParams.find("error") != responseParams.end() 
                            ? responseParams["error"] : "Update failed - bad status";
        responseParams["error"] = errorMessage;
    } 

    return responseParams; // Return error map in silent mode
}

std::unordered_map<std::string, std::string> Protocol::config(const std::string& uid, const std::unordered_map<std::string, std::string>& config, int verbose) {
    if (!initialized) {
        if (verbose) {
            throw ProtocolNotInitializedException("Protocol::config", "Protocol not initialized before calling config method");
        }
        return false; // Return false in silent mode
    }
    
    if (uid.empty()) {
        if (verbose) {
            throw ValueNotFoundException("Protocol::config", "Sensor UID cannot be empty");
        }
        return false; // Return false in silent mode
    }
    
    try {
        // Build configuration request
        std::string request = "?type=CONFIG";
        request += "&id=" + uid;
        
        // Add configuration parameters
        for (const auto& configParam : config) {
            request += "&" + configParam.first + "=" + configParam.second;
        }
        
        std::string request = buildMessage(request);
        
        // Send request and receive response
        sendMessage(request);
        std::string response = receiveMessage();
        
        // Parse response
        auto responseParams = parseMessage(response);
        
        // Check if UID from response matches request
        if (responseParams.find("id") == responseParams.end() || responseParams["id"] != uid) {
            if (verbose) {
                throw ProtocolMethodFailException("Protocol::config", "Response UID mismatch - expected: " + uid + ", received: " + 
                              (responseParams.find("id") != responseParams.end() ? responseParams["id"] : "none"));
            }
            return false; // Return false in silent mode
        }
        
        // Check if configuration was successful
        return (responseParams.find("status") != responseParams.end() && 
                responseParams["status"] == "1");
    } catch (const Exception& e) {
        if (verbose) {
            throw e; // Re-throw the exception in verbose mode
        }
        return false; // Return false in silent mode
    }
    catch (std::exception& e) {
        if (verbose) {
            throw ProtocolMethodFailException("Protocol::config", e.what());
        }
        return false; // Return false in silent mode
    }
    catch (...) {
        if (verbose) {
            throw ProtocolMethodFailException("Protocol::config", "Unknown error occurred during config");
        }
        return false; // Return false in silent mode
    }
}

bool Protocol::reset(const std::string& uid, int verbose) {
    if (!initialized) {
        if (verbose) {
            throw ProtocolNotInitializedException("Protocol::reset", "Protocol not initialized before calling reset method");
        }
        return false; // Return false in silent mode
    }
    
    if (uid.empty()) {
        if (verbose) {
            throw ValueNotFoundException("Protocol::reset", "Sensor UID cannot be empty");
        }
        return false; // Return false in silent mode
    }
    
    try {
        // Build reset request
        std::unordered_map<std::string, std::string> params;
        params["type"] = "RESET";
        params["id"] = uid;
        
        std::string request = buildMessage(params);
        
        // Send request and receive response
        sendMessage(request);
        std::string response = receiveMessage();
        
        // Parse response
        auto responseParams = parseMessage(response);
        
        // Check if UID from response matches request
        if (responseParams.find("id") == responseParams.end() || responseParams["id"] != uid) {
            if (verbose) {
                throw ProtocolMethodFailException("Protocol::reset", "Response UID mismatch - expected: " + uid + ", received: " + 
                              (responseParams.find("id") != responseParams.end() ? responseParams["id"] : "none"));
            }
            return false; // Return false in silent mode
        }
        
        // Check if reset was successful
        return (responseParams.find("status") != responseParams.end() && 
                responseParams["status"] == "1");
    } catch (const Exception& e) {
        if (verbose) {
            throw e; // Re-throw the exception in verbose mode
        }
        return false; // Return false in silent mode
    }
    catch (std::exception& e) {
        if (verbose) {
            throw ProtocolMethodFailException("Protocol::reset", e.what());
        }
        return false; // Return false in silent mode
    }
    catch (...) {
        if (verbose) {
            throw ProtocolMethodFailException("Protocol::reset", "Unknown error occurred during reset");
        }
        return false; // Return false in silent mode
    }
}

bool Protocol::connect(const std::string& uid, const std::string& pins, int verbose) {
    if (!initialized) {
        if (verbose) {
            throw ProtocolNotInitializedException("Protocol::connect", "Protocol not initialized before calling connect method");
        }
        return false; // Return false in silent mode
    }
    
    if (uid.empty()) {
        if (verbose) {
            throw ValueNotFoundException("Protocol::connect", "Sensor UID cannot be empty");
        }
        return false; // Return false in silent mode
    }
    
    try {
        // Build connect request
        std::unordered_map<std::string, std::string> params;
        params["type"] = "CONNECT";
        params["id"] = uid;
        params["pins"] = pins;
        
        std::string request = buildMessage(params);
        
        // Send request and receive response
        sendMessage(request);
        std::string response = receiveMessage();
        
        // Parse response
        auto responseParams = parseMessage(response);
        
        // Check if UID from response matches request
        if (responseParams.find("id") == responseParams.end() || responseParams["id"] != uid) {
            if (verbose) {
                throw ProtocolMethodFailException("Protocol::connect", "Response UID mismatch - expected: " + uid + ", received: " + 
                              (responseParams.find("id") != responseParams.end() ? responseParams["id"] : "none"));
            }
            return false; // Return false in silent mode
        }
        
        // Check if connection was successful
        return (responseParams.find("status") != responseParams.end() && 
                responseParams["status"] == "1");
    } catch (const Exception& e) {
        if (verbose) {
            throw e; // Re-throw the exception in verbose mode
        }
        return false; // Return false in silent mode
    }
    catch (std::exception& e) {
        if (verbose) {
            throw ProtocolMethodFailException("Protocol::connect", e.what());
        }
        return false; // Return false in silent mode
    }
    catch (...) {
        if (verbose) {
            throw ProtocolMethodFailException("Protocol::connect", "Unknown error occurred during connect");
        }
        return false; // Return false in silent mode
    }
}

bool Protocol::disconnect(const std::string& uid, int verbose) {
    if (!initialized) {
        if (verbose) {
            throw ProtocolNotInitializedException("Protocol::disconnect", "Protocol not initialized before calling disconnect method");
        }
        return false; // Return false in silent mode
    }
    
    if (uid.empty()) {
        if (verbose) {
            throw ValueNotFoundException("Protocol::disconnect", "Sensor UID cannot be empty");
        }
        return false; // Return false in silent mode
    }
    
    try {
        // Build disconnect request
        std::unordered_map<std::string, std::string> params;
        params["type"] = "DISCONNECT";
        params["id"] = uid;
        
        std::string request = buildMessage(params);
        
        // Send request and receive response
        sendMessage(request);
        std::string response = receiveMessage();
        
        // Parse response
        auto responseParams = parseMessage(response);
        
        // Check if UID from response matches request
        if (responseParams.find("id") == responseParams.end() || responseParams["id"] != uid) {
            if (verbose) {
                throw ProtocolMethodFailException("Protocol::disconnect", "Response UID mismatch - expected: " + uid + ", received: " + 
                              (responseParams.find("id") != responseParams.end() ? responseParams["id"] : "none"));
            }
            return false; // Return false in silent mode
        }
        
        // Check if disconnection was successful
        return (responseParams.find("status") != responseParams.end() && 
                responseParams["status"] == "1");
    } catch (const Exception& e) {
        if (verbose) {
            throw e; // Re-throw the exception in verbose mode
        }
        return false; // Return false in silent mode
    }
    catch (std::exception& e) {
        if (verbose) {
            throw ProtocolMethodFailException("Protocol::disconnect", e.what());
        }
        return false; // Return false in silent mode
    }
    catch (...) {
        if (verbose) {
            throw ProtocolMethodFailException("Protocol::disconnect", "Unknown error occurred during disconnect");
        }
        return false; // Return false in silent mode
    }
}

bool Protocol::isInitialized() {
    return initialized;
}

std::string Protocol::getApiVersion() {
    return API_VERSION;
}